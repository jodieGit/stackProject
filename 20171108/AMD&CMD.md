# AMD && CMD的区别
==================================================

## 背景：
    * 前端底层共用部分，多人操作会经常出现紊乱现象，所以应运而生，产生了命名空间的概念，防止代码间的相互冲突，不变维护，但是时间一长，命名空间的长度简直超乎人的想象，使用起来并不理想。经过了一系列的更新，还是需要自己手动添加依赖项，灰常令人讨厌。这时候模块化编程应运而生。

    * 出现CommonJS，但是这个更加偏向于服务端，一次性加载所有模块，然后按需取得所需要的模块缓存处理。这个对于服务器端，因为可以保存在硬盘，不会有太大的影响；但是在浏览器端，因为需要从服务器上获取，这中间是有http请求的，会存在时间差，效果并不是很好。解决了模块化问题，但是不适合运用于浏览器端。随后就出现了AMD和CMD。

## 介绍

### AMD: 
    * "Asynchronous Module Definition", "异步模块定义"，是RequireJS在推广过程中对模块的规范化定义。模块都是异步加载，不影响后面的语句的执行。这里的异步是指执行时不影响浏览器的其他操作，比如DOM渲染之类的，而加载内部还是运用同步的，加载完成后立即执行；加载模块时，会先加载该模块的依赖模块，当依赖比较多时，会先将依赖模块加载好，所以说是"依赖前置"。
    
    * requireJS解决了如下问题：
        1、多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 
        2、js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 

    * demo:

        `   
            <!--定义模块 myModule.js -->
            define(['dependency'], function() {
                var name = 'jodie';
                function printName() {
                    console.log(name);
                }
                return {
                    printName: printName
                }
            }); 
            
            <!-- 加载模块 -->
            require(['myModule'], function(my) {
                my.printName();
            });
        `

### CMD:
    * "Common Module Definition", "通用模块定义"，是SeaJS在推广过程中对模块的规范化定义。主要思想是"按需加载，依赖就近"

    * SeaJS解决的问题基本和RequireJS保持一致，但是模块定义方式和模块加载时机（运行解析）有所不同。

    * 语法：

        Sea.js 推崇一个模块一个文件，遵循统一的写法 
        define(id?, deps?, factory) 
        因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id；CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写；factory是一个函数，有三个参数，function(require, exports, module)；

        require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id)
        exports 是一个对象，用来向外提供模块接口
        module 是一个对象，上面存储了与当前模块相关联的一些属性和方法

    * demo
    
    `
        <!-- 定义模块 myModule.js -->
        define(function(require, exports, module) {
            var $ = require('jquery.js');
            $('.div').addClass('active');
        });

        <!-- 加载模块 -->
        seajs.use(['myModule.js'], function() {

        });
    `

### AMD && CMD的区别

    * 最明显的区别是模块定义时对依赖的处理方式不同
        1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 
        2、CMD推崇就近依赖，只有在用到某个模块的时候再去require 


    * AMD && CMD 都是异步加载模块，AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行；

    CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的；

    这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因。

    


